#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           clawMotor,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------

	This code was created by Wyatt Johnson and Eric Bowden

	Robotics specifications
	Wheel Diameter - 4"
	One rotation is 4pi inches or roughly 12.5"(about a foot)
	forwards(speed) - function for going forward (ONLY IN THIS PROGRAM)
	One full rotation for these motors in the encoders is between 350-353, so to go 1 rot encoders = 351
	1 tile is 2ft, but because of the loss of mesh is roughly 22"

------------------------------------------------------*/

// Speed Variables
int turnSpeed = 70; //used in the turnLeft() and turnRight() functions and controls the speed of the turn

//Distance Variables
int rotationTicks = 351; //number of encoder ticks in one rotation
float wheelDistance = 4*PI; //distance that one rotation goes
int tileWidth = 22; //width of tile in inches
int turnTicks = 392; //number of ticks for a 90 degree turn
float firstForward; //distance in ticks that is calculated later


int clearEncoders(){ //clears Encoders values
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	return 0;

}

//Forward Speed Variables(Troubleshooting)

int startForwardSpeed = 30; //default motor speed
int rotTicks; //variable we use later

/*------------------------------------------------------

	The following functions are for turning

------------------------------------------------------*/


void turnLeft (int speed){
	clearEncoders();
	while ((abs(nMotorEncoder[rightMotor]) + abs(nMotorEncoder[leftMotor])) / 2 < 392)
	{
		if (abs(nMotorEncoder[leftMotor]) > abs(nMotorEncoder[rightMotor])){
			motor[leftMotor] = speed++;
			motor[rightMotor] = speed++;

		}
		else if (abs(nMotorEncoder[leftMotor]) < abs(nMotorEncoder[rightMotor])){
			motor[rightMotor] = speed--;
			motor[leftMotor] = speed++;

		}
		else {
			motor[rightMotor] = speed;
			motor[leftMotor] = speed;
		}

	}

}
//Simply reversed the PID here because its turning right versus turning left
void turnRight (int speed){
	clearEncoders();
	while ((abs(nMotorEncoder[rightMotor]) + abs(nMotorEncoder[leftMotor])) / 2 < 392)
	{
		if (abs(nMotorEncoder[leftMotor]) > abs(nMotorEncoder[rightMotor])){
			motor[leftMotor] = speed--;
			motor[rightMotor] = speed--;

		}
		else if (abs(nMotorEncoder[leftMotor]) < abs(nMotorEncoder[rightMotor])){
			motor[rightMotor] = speed++;
			motor[leftMotor] = speed++;

		}
		else {
			motor[rightMotor] = speed;
			motor[leftMotor] = speed;
		}

	}

}


/*------------------------------------------------------

	Encoder straightening Function
	tileDistance is the distance that you want to move
	speed is the chosen speed of the robot

------------------------------------------------------*/
int move(int tileDistance, int speed)
{
	clearEncoders();
	int ticks = (((tileWidth*tileDistance)/ wheelDistance) *rotationTicks);

	while(((nMotorEncoder[leftMotor] + nMotorEncoder[rightMotor]) / 2 ) <= ticks ){

	if(nMotorEncoder[leftMotor] > nMotorEncoder[rightMotor]) {
		motor[leftMotor] = speed -3;
		motor[rightMotor]=speed +3;
	}
	else if(nMotorEncoder[leftMotor] < nMotorEncoder[rightMotor]){
		motor[leftMotor] = speed -3;
		motor[rightMotor]=speed +3;
	}
	else
	{
		motor[rightMotor] = speed;
		motor[leftMotor] = speed;
	}

	}
	clearEncoders();
	return 0;
}


/*------------------------------------------------------

	 Super Easy to use rotating (tank turn) function:
	 first parameter is the degrees you want to rotate
	 second parameter is the speed you want do this
	 uses the absolute value of what the motorEncoders read to
	 determine PID and straightening
	 Program is smarter in that it can negative if the input parameter is negative by using the abs() cmd
	 to see if a + abs(a) is 0 (if its negative) or not (if its positive)

------------------------------------------------------*/

void rotate(int degrees, int speed)
{
	clearEncoders(); //customary first code for every function using encoders
	/*
		392/90 = x/degrees // degrees * 392 = 90x // (degrees * 392)/ 90  = x
	*/
	rotTicks = abs((degrees * turnTicks)/90); //finds the absolute value so ticks is always positive

	while((abs(nMotorEncoder[rightMotor]) + abs(nMotorEncoder[leftMotor]))/2 < rotTicks )
	if (abs(nMotorEncoder[leftMotor]) > abs(nMotorEncoder[rightMotor])){
		if (degrees + abs(degrees) == 0){ //so if the number is negative
			motor[leftMotor] = speed++;
			motor[rightMotor] = speed++;
		}
		else if (degrees + abs(degrees) != 0){
			motor[leftMotor] = speed--;
			motor[rightMotor] = speed--;
			/*
				logically this makes since because on a left turn, the left motor is going backwards
			so subtracting is going to make it go faster and vise versa for the right motor

			*/
		}

	}
	else if (abs(nMotorEncoder[leftMotor]) < abs(nMotorEncoder[rightMotor])){
		if (degrees + abs(degrees) == 0){ //if number is negative
			motor[leftMotor] = speed--;
			motor[rightMotor] = speed--;

	}
		else if (degrees + abs(degrees) != 0){ //if number is positive
			motor[leftMotor] = speed++;
			motor[rightMotor] = speed++;

		}
	}
	else {
		motor[leftMotor] = speed;
		motor[rightMotor] = speed;

	}

}

/* ----------------------------------------------------

	TASK MAIN - all of the functional code goes here.
	If you want the robot to go forward, turn, etc, put it here

------------------------------------------------------*/

task main()
{

/*----------------------------------------------------

								PID - straightening code

----------------------------------------------------*/

	move(2.5, 50);
	turnLeft(50);
	move(2.9, 50);
	turnRight(50);
	move(2.15, 50);
	turnLeft(50);
	move(2.85, 50);
	rotate(45);
	move(1.1);
	rotate(45);
	move(3, 50);

}
