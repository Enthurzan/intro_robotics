
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           clawMotor,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(DatalogSeries, 0, "rightIEM", Sensors, Sensor, I2C_1, 50)
#pragma config(DatalogSeries, 1, "leftIEM", Sensors, Sensor, I2C_2, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------

	One 90D turn is 392 ticks
	Equations for the number of tick is
	(N * 392) / 90 = #of ticks to turn n degreesToRadians
	THIS TEST CODE IS TO TEST THE turnLeft() AND turnRight() FUNCTIONS

------------------------------------------------------*/

int turnTicks = 392;
float rotTicks;
int turnSpeed = 50;


void clearEncoders ()
{
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

}

void turnLeft (int speed){
	clearEncoders();
	while ((abs(nMotorEncoder[rightMotor]) + abs(nMotorEncoder[leftMotor])) / 2 < 392)
	{
		if (abs(nMotorEncoder[leftMotor]) > abs(nMotorEncoder[rightMotor])){
			motor[leftMotor] = speed++;
			motor[rightMotor] = speed++;

		}
		else if (abs(nMotorEncoder[leftMotor]) < abs(nMotorEncoder[rightMotor])){
			motor[rightMotor] = speed--;
			motor[leftMotor] = speed++;

		}
		else {
			motor[rightMotor] = speed;
			motor[leftMotor] = speed;
		}

	}

}
//Simply reversed the PID here because its turning right versus turning left
void turnRight (int speed){
	clearEncoders();
	while ((abs(nMotorEncoder[rightMotor]) + abs(nMotorEncoder[leftMotor])) / 2 < 392)
	{
		if (abs(nMotorEncoder[leftMotor]) > abs(nMotorEncoder[rightMotor])){
			motor[leftMotor] = speed--;
			motor[rightMotor] = speed--;

		}
		else if (abs(nMotorEncoder[leftMotor]) < abs(nMotorEncoder[rightMotor])){
			motor[rightMotor] = speed++;
			motor[leftMotor] = speed++;

		}
		else {
			motor[rightMotor] = speed;
			motor[leftMotor] = speed;
		}

	}

}


task main()
{



}
