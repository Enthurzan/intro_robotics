
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           clawMotor,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(DatalogSeries, 0, "rightIEM", Sensors, Sensor, I2C_1, 50)
#pragma config(DatalogSeries, 1, "leftIEM", Sensors, Sensor, I2C_2, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------

	One 90D turn is 392 ticks
	Equations for the number of tick is
	(N * 392) / 90 = #of ticks to turn n degreesToRadians
	THIS TEST CODE IS TO TEST THE turnLeft() AND turnRight() FUNCTIONS

------------------------------------------------------*/

//Varible Library
int baseCounts = 392; //number of encoder counts for a 90 degree left
int leftStatus; // 0 is equal / 1 is left Motor to fast / 2 is right motor too fast
int rightStatus; // 0 is equal / 1 is left Motor to fast / 2 is right motor too fast

void clearEncoders () //function that sets all nMotorEncoder values to 0 (reset / zeroing)
{
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

}

void turnLeft(int speed){
	clearEncoders(); //clears the motor encoders
	while (((nMotorEncoder[rightMotor] + abs(nMotorEncoder[leftMotor]))/2) < baseCounts){ //checks to see if the motors have gone the correct distance yet
		if ((abs(nMotorEncoder[leftMotor]))	< nMotorEncoder[rightMotor]){ //assigns a value to leftStatus that can determine which motor is running fast or slow
			leftStatus = 2;

		}
		else if ((abs(nMotorEncoder[leftMotor])) > nMotorEncoder[rightMotor]){
			leftStatus = 1;

		}
		else {
			leftStatus =  0;

		}
		switch (leftStatus) {
		case 0: //if the encoder counts are equal
			motor[rightMotor] = speed; //set right motor to speed
			motor[leftMotor] = -speed; //set left motor to the opposite of speed
			break;

		case 1: //if the left motor encoder counts more than the right motor encoder
			motor[rightMotor] = speed+1; //set right motor to speed + 1(make it go faster)
			motor[leftMotor] = -speed+1; //set the left motor to the opposite of speed + 1 (it will slow down)
			break;

		case 2: //if the right motor encoder counts more than the left motor encoder
			motor[rightMotor] = speed-1; //set the right motor to speed - 1 (make it slow down)
			motor[leftMotor] = -speed-1; //set the left motor to the opposite of speed - 1 (it should speed up)
			break;

		}
	}
}

task main()
{
	turnLeft();


}
