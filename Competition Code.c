#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           intakeMotor,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           clawMotor,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port8,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armMotorTwo,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int globalSpeed = 40; //speed for drivetrain 393 motors
bool isPlayed = false; //prevents the autonomous from being played more than once in case Btn9R is pressed accidently


/*------------------------------------------------------

This code was created by Wyatt Johnson and Eric Bowden

Robotics specifications
Wheel Diameter - 4"
One rotation is 4pi inches or roughly 12.5"(about a foot)
forwards(speed) - function for going forward (ONLY IN THIS PROGRAM)
One full rotation for these motors in the encoders is between 350-353, so to go 1 rot encoders = 351
1 tile is 2ft, but because of the loss of mesh is roughly 22"

------------------------------------------------------*/

// Speed Variables
int turnSpeed = 70; //used in the turnLeft() and turnRight() functions and controls the speed of the turn

//Distance Variables
int rotationTicks = 351; //number of encoder ticks in one rotation
float wheelDistance = 4*PI; //distance that one rotation goes
int tileWidth = 22; //width of tile in inches
int turnTicks = 392; //number of ticks for a 90 degree turn
float firstForward; //distance in ticks that is calculated later


int clearEncoders(){ //clears Encoders values
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	return 0;

}

//Forward Speed Variables(Troubleshooting)

int startForwardSpeed = 50; //default motor speed
int rotTicks; //variable we use later

//Speed are arranged like this so that they can be changed individually

int forwardLeft = startForwardSpeed;
int forwardRight = startForwardSpeed;

int forward() { //tells robot to move forward at a certain speed for a certain time
	motor[rightMotor] = forwardRight;
	motor[leftMotor] = forwardLeft;
	return 0;

}
/*------------------------------------------------------

The following functions are for turning

------------------------------------------------------*/


int turnLeft() //use this function to turn left
{
	clearEncoders();

	while((nMotorEncoder[rightMotor] <= turnTicks) && (nMotorEncoder[leftMotor] >= -(turnTicks))){
		motor[leftMotor] = -turnSpeed;
		motor[rightMotor] = turnSpeed;
	}
	return 0;
}


int turnRight () //use this function to turn right
{
	clearEncoders();
	while(nMotorEncoder[rightMotor] >= -(turnTicks) && nMotorEncoder[leftMotor] <= turnTicks){
		motor[leftMotor] =  turnSpeed; //left motor goes backwards
		motor[rightMotor] = -(turnSpeed); //right motor goes forward
	}
	return 0;

}

/*------------------------------------------------------

This function can be used to make the robot use encoders to move forward a certain distance
The integer distance parameter is the tile distance.
Later versions of this function may use inches parameter versus tile distance because that would be easier
to measure
This function automatically clears encoders, calculates the number of ticks to count, and
moves the robot that distance

------------------------------------------------------*/

int forwardDistance(float distance){
	clearEncoders(); //clear the encoders
	firstForward = (((tileWidth*distance)/ wheelDistance) *rotationTicks); //calculates distance
	while((nMotorEncoder[rightMotor] <= firstForward) &&(nMotorEncoder[leftMotor] <= firstForward) ){
		forward(); //robot moves forward
	}
	return 0;
}
// Move Function
void move(int tileDistance, int speed)
{
	//clear the encoders
	clearEncoders();
	//calculates number of encoder ticks from the number of tiles specified in the parameter
	int ticks = (((tileWidth*tileDistance)/ wheelDistance) *rotationTicks);
	//while the average of the encoder values is less than the distance they need to go
	while(((nMotorEncoder[leftMotor] + nMotorEncoder[rightMotor]) / 2 ) <= ticks ){
		//checks to see if the left motor has gone farther than the right motor
		if(nMotorEncoder[leftMotor] > nMotorEncoder[rightMotor]) {
			//changes speed by interval of 3
			motor[leftMotor] = speed -3;
			motor[rightMotor]=speed +3;
		}
		//checks to see if the right motor has gone farther than the left motor
		else if(nMotorEncoder[leftMotor] < nMotorEncoder[rightMotor]){
			//slows the left motor by 3 and increases the speed of the right motor by three
			motor[leftMotor] = speed -3;
			motor[rightMotor]=speed +3;
		}
		else
		{
			//sets motor speeds equal to maintain order and the correct speed
			motor[rightMotor] = speed;
			motor[leftMotor] = speed;
		}

	}
	//clear the encoders
	clearEncoders();
}

task main () {
	while (true){
		//rightMotor is controlled by Ch2 on joystick
		motor[rightMotor] = vexRT[Ch2];
		//leftMotor is controlled by Ch3 on joystick
		motor[leftMotor]= vexRT[Ch3];
		//if button 6U is pressed, make arm go up
		if (vexRT[Btn6U] == 1) {
			motor[armMotor] = -70;
			motor[armMotorTwo] = -70;

		}
		// if button 6D is pressed, make arm go at speed 20
		else if (vexRT[Btn6D] == 1)
		{
			motor[armMotor] = 70;
			motor[armMotorTwo] = 70;

		}
/*------------------------------------------------------

	Code for autonomous play - now this is not technically autonomous but is the autonomous play

------------------------------------------------------*/

		else if (Btn8R == 1 && isPlayed == false){
			move(3, 50); //go forward 2.25 tiles
			motor[rightMotor] = turnSpeed; //set right motor to turnSpeed
			motor[leftMotor] = -(turnSpeed); //set left motor to the opposite of turn speed
			wait1Msec(375);
			move(3.5, 50);
			motor[rightMotor] = turnSpeed; //set right motor to turnSpeed
			motor[leftMotor] = -(turnSpeed); //set left motor to the opposite of turn speed
			wait1Msec(325);
			turnLeft();
			move(4.5, 50);
			motor[rightMotor] = turnSpeed; //set right motor to turnSpeed
			motor[leftMotor] = -(turnSpeed); //set left motor to the opposite of turn speed
			wait1Msec(500);
			move(4.5, 50);
			isPlayed = true;
		}
		//if no button is pressed, make both motors stop
		else
		{
			motor[armMotor] = 0;
			motor[armMotorTwo] = 0;


		}
	}
}

/*

This code was created by Wyatt Johnson
HP Robotics
C Period
April 28, 2016

*/
